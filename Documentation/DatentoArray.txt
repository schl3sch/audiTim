Richtig w√§re -> TDOA / Beamforming -> Messung der Zeitdifferenz der Schallwelle zwischen den Sensoren
                                   -> daraus mit Trilateration oder GCC-PHAT den Einfallswinkel und Ort berechnen
                                   -> nicht umsetzbar aktuell wegen zu ungenauer Zeitpunkte

Bilineare Interpolation -> Flache ebene der werte -> wenig sinnvoll
    for (let row = 0; row < 10; row++) {
      const y = row / 9;
      const rowData = [];
      for (let col = 0; col < 10; col++) {
        const x = col / 9;
        const V =
          sensorValues.d1 * (1 - x) * (1 - y) +
          sensorValues.d2 * x * (1 - y) +
          sensorValues.d3 * (1 - x) * y +
          sensorValues.d4 * x * y;
        rowData.push(Number(V.toFixed(2)));
      }
      grid.push(rowData);
    }

Inverser Distanzgewichtung (IDW) -> grobe gewichtung weg vom Sensor -> Grobe anzeige wo im Raum
    const power = 2; // IDW: Distanzexponent (2 = inverse quadratische Gewichtung)
    for (let row = 0; row < 10; row++) {
      const y = row / 9;
      const rowData = [];

      for (let col = 0; col < 10; col++) {
        const x = col / 9;

        let numerator = 0;
        let denominator = 0;

        for (const [key, { x: sx, y: sy }] of Object.entries(sensorPositions)) {
          const value = sensorValues[key];
          const dx = x - sx;
          const dy = y - sy;
          const distance = Math.sqrt(dx * dx + dy * dy) || 0.0001; // Verhindert Division durch 0

          const weight = 1 / Math.pow(distance, power);
          numerator += value * weight;
          denominator += weight;
        }

        const interpolatedValue = numerator / denominator;
        rowData.push(Number(interpolatedValue.toFixed(2)));
      }

      grid.push(rowData);
    }

Physikalisches Modell ‚Äì R√ºckw√§rtsprojektion:
    Du baust ein 2D-Gitter (Heatmap) √ºber den Raum
    F√ºr jeden Punkt auf dem Gitter:
        Berechne den erwarteten Pegel an jedem Mikrofon, wenn hier die Quelle w√§re
        Vergleiche das mit den echten Messwerten
        Speichere die Abweichung (z.‚ÄØB. Fehler-Quadrat)
    Heatmap zeigt dann:
        Je geringer der Fehler, desto wahrscheinlicher war hier die Quelle
    
    L = L‚ÇÄ - 20 * log‚ÇÅ‚ÇÄ(d) -> L = gemessener Pegel, L0 = Lautst√§rke direkt an der Quelle, ùëë = Abstand zur Quelle

Maximum Likelihood Estimation (MLE):
    Du brauchst ein Wahrscheinlichkeitsmodell ùëÉ( Messwerte ‚à£ Quelle¬†an¬†(ùë•,ùë¶ ))
        F√ºr jedes (x,y) im Raum:
            Berechne die Wahrscheinlichkeit, dass dort die Quelle war, basierend auf den realen Lautst√§rkewerten
            Der Punkt mit der h√∂chsten Wahrscheinlichkeit ist deine gesch√§tzte Quelle
        P = exp(-((L_measured - L_expected)¬≤ / 2œÉ¬≤))
    Wie wahrscheinlich ist es, dass ein Punkt (x, y) mit Lautst√§rke L die gemessenen Sensorwerte s‚ÇÅ...s‚ÇÑ erzeugt hat?
        das klassische Modell:
            s·µ¢ = L - 20 * log10(d·µ¢) + Œµ
                s·µ¢: gemessene Lautst√§rke am Sensor i
                L: Lautst√§rke der Quelle
                d·µ¢: Abstand von der Quelle zum Sensor i
                Œµ: Messfehler (normalverteilt, Mittelwert 0)
            L(x,y,L0)=Œ†(i=1..4)[1/‚àö(2œÄœÉ2)]‚àóexp(‚àí(si‚àí(L0‚àí20log10(di)))2/(2œÉ2))
                -> Das ist das Produkt der Wahrscheinlichkeiten, dass jeder Sensorwert so gemessen wurde, wenn sich die Quelle an (x, y) mit Lautst√§rke L‚ÇÄ befindet.

    Dann m√∂glich:
        Modell: Zwei Quellen (x‚ÇÅ, y‚ÇÅ, L‚ÇÅ) und (x‚ÇÇ, y‚ÇÇ, L‚ÇÇ)
        s·µ¢ ‚âà L‚ÇÅ - 20 log10(d·µ¢‚ÇÅ) + L‚ÇÇ - 20 log10(d·µ¢‚ÇÇ)

Weighted Centroid Localization (WCL):
    Jeder Sensorwert wirkt wie eine Gravitationskraft, die die Quelle ‚Äûzu sich zieht‚Äú.
    Du rechnest daraus einen gewichteten Mittelpunkt, der der Quelle am n√§chsten kommt.
    Du kannst auf deiner Heatmap z.‚ÄØB. einen Gau√ü-Hotspot an diesem Punkt erzeugen
    
    centerX = (x‚ÇÅ¬∑w‚ÇÅ + x‚ÇÇ¬∑w‚ÇÇ + x‚ÇÉ¬∑w‚ÇÉ + x‚ÇÑ¬∑w‚ÇÑ) / (w‚ÇÅ + w‚ÇÇ + w‚ÇÉ + w‚ÇÑ)
    centerY = (y‚ÇÅ¬∑w‚ÇÅ + y‚ÇÇ¬∑w‚ÇÇ + y‚ÇÉ¬∑w‚ÇÉ + y‚ÇÑ¬∑w‚ÇÑ) / (w‚ÇÅ + w‚ÇÇ + w‚ÇÉ + w‚ÇÑ)

Machine Learning:
    Du trainierst ein Modell (z.‚ÄØB. KNN, RandomForest oder MLP), das aus 4 dB-Werten die Position der Quelle voraussagt.
    Damit kannst du direkt aus Messwerten auf die Position schlie√üen.

| Methode                                | Typ                       | Vorteile                                                       | Nachteile                                                           | Quelle bestimmbar?             |
| -------------------------------------- | ------------------------- | -------------------------------------------------------------- | ------------------------------------------------------------------- | ------------------------------ |
| Bilineare Interpolation                | Interpolation             | - Schnelle, symmetrische Heatmap (linearen Verl√§ufen)          | - Kein Bezug zu physikalischer Ausbreitung                          | üî∏ Ungef√§hr (Ebene)            | rein mathematische Gl√§ttung, die keinen R√ºckschluss auf die reale Schallquelle erlaubt. Nutzt keine physikalische Information.
| IDW (Inverse Distance Weighting)       | Interpolation             | - Einfach umzusetzen Glatte Heatmap Intuitiv                   | - Keine echte Lokalisierung Quelle verschwimmt bei mehreren Peaks   | üî∏ Ungef√§hr (Wellen)           | du kriegst ein weiches Feld, aber kein klares Zentrum. Das Maximum liegt oft in der N√§he der lautesten Sensoren, aber kann je nach D√§mpfung verschwommen sein.
| Physikalisches Modell (Distance-Based) | Modellbasiert             | - Ber√ºcksichtigt reale Schallausbreitung                       | - Annahme √ºber Quellpegel n√∂tig Rechenintensiver                    | ‚úÖ Ja (als Heatmap)            | du erh√§ltst eine Heatmap, deren Maximum mit hoher Wahrscheinlichkeit am Ort der st√§rksten Schallquelle liegt. Kann auf Wunsch scharf oder breit dargestellt werden.
| Maximum Likelihood Estimation (MLE)    | Wahrscheinlichkeitsmodell | - Statistisch fundiert Robust gegen Messrauschen               | - Braucht Modell f√ºr Messfehler Langsamer als WCL                   | ‚úÖ Ja (als Wahrscheinlichkeit) | du bekommst eine Wahrscheinlichkeitsverteilung √ºber die Raumfl√§che. Wo die Wahrscheinlichkeit am h√∂chsten ist, dort wird die Quelle vermutet.
| WCL (Weighted Centroid)                | Sch√§tzwert                | - Leicht zu implementieren Guter erster Indikator              | - Ungenau bei stark asymmetrischer Verteilung                       | ‚úÖ Ja (1 Koordinate)           | liefert dir ein einzelnes (x,y) als Zentrum aller Lautst√§rkewirkungen. Funktioniert gut, wenn ein dominanter Bereich laut ist. Ideal f√ºr ‚ÄûDozent vorne‚Äú vs ‚ÄûStudent hinten‚Äú.
| Machine Learning Regression            | Lernbasiert               | - Extrem schnell nach Training Erweiterbar auf komplexe Muster | - Trainingsdaten n√∂tig Keine Garantie bei Out-of-Distribution Cases | ‚úÖ Ja (xy direkt)              | du bekommst direkt ein (x, y) zur√ºck, wenn das Modell gut trainiert ist. Nutzt implizit alle verf√ºgbaren Muster.

Machine Learning wsl beste wenn man es gut macht (hoher aufwand)
WCL am besten f√ºr wo in dem raum ist der Lautst√§rken Mittelpunkt
IDW am besten f√ºr Hinten ist es noch lauter als vorne
MLE viel aufwand aber k√∂nnte gut werden?

Mischung aus IDW und WCL:
    1. Virtuelle Sensoren / Quelle modellieren
        F√ºge zus√§tzliche Punkte in die Heatmap, die keine echten Sensoren sind, aber simulierte Quellen darstellen.
        Erstelle hypothetisch 10‚Äì20 Positionen im Raum (Mitte, Vorderreihe, R√ºckreihe usw.).
        F√ºr jeden Punkt berechnest du:
            Wie wahrscheinlich ist es, dass von hier der Schall kam, basierend auf der Distanz zu den Sensoren und deren Lautst√§rke.
        Dann: Summe √ºber alle hypothetischen Quellen ‚Üí erzeugt deinen Heatmap-Wert.

    2. Kombiniere mit WCL-Light
        Berechne zus√§tzlich zum IDW die "wahrscheinlichste Quelle" mit WCL (also den gewichteten Mittelpunkt):
        Dann setz einen Peak an dieser Stelle und blende IDW drum herum weich ein (z.‚ÄØB. additiv mit einem Gauss-Blob oder Gradient).